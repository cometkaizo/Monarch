# Monarch

##### Table of Contents
- [Overview](#key-features)  
- [Installation](#installation)
- [Usage](#usage)
  - [Compiler](#compiler)
  - [Virtual Machine](#virtual-machine-vm)
  - [Sample Source Codes](#sample-source-codes)
  - [How To](#how-to)
- [Key Features](#key-features)
  - [Feature List](#feature-list)
  - [Custom Syntax](#custom-syntax)
  - [Macros](#macros)

## Overview
Monarch is a bytecode-based, proof-of-concept programming language that aims to explore new programming concepts through a modular and reflective design. Monarch will support and/or already supports features such as the definition of custom syntax, interactions with the compiler during compilation, custom AST rules, and possibly even extensions to the VM.

Currently, Monarch's compiler is written in Java. It will be rewritten in Monarch in the future to allow for interactions with the compiler. The compiler outputs platform-independent compiled files in the form of custom bytecode instructions.

The Monarch Virtual Machine is written in C, and executes the bytecode instructions outputted by the compiler. Monarch defines its own bytecode instruction set. The VM is stack-based.

## Installation
1. Go to the [Latest Release](https://www.github.com/cometkaizo/Monarch/releases/latest) and **download the 3 files: `monarchc.jar`, `MonarchVM.exe`, and `MonarchVM.bat`**.
2. Run `monarchc.jar` to run the compiler (this requires Java 21) to compile source code
3. Or run `MonarchVM.bat` to run a compiled file

See below for usage instructions for the compiler and virtual machine.

## Usage
### Compiler
Once the compiler jar file has been downloaded, the compiler can be run by opening the folder that contains it in the terminal (cmd) and running:
```
java -jar monarchc.jar
```

The compiler has three commands:
- `compile <file-location>` - compiles the source code file at `file-location` to a bytecode file with the same name (`.mnrc`)
  - e.g.: `compile main.txt`
- `entrypoint <file-location> <function-name>` - creates an entrypoint `.mnrc` bytecode file that will call the given function in the given file.
  - **Important: this is necessary to run a file. Directly running the file without an entrypoint file does not work.**
  - e.g.: `entrypoint main.txt main`
- `exit` - exits the compiler

Note: file paths cannot contain spaces.

The compiler will provide you with feedback if a command is entered incorrectly.
### Virtual Machine (VM)
To run the VM, navigate to folder that contains VM, and run:
```
MonarchVM.bat
```

After running the VM, a command prompt will open. You can enter the absolute or relative file path to a compiled bytecode file (`.mnrc`) in order to run it. **Important: you cannot directly run a compiled bytecode file, you can only run an entrypoint file generated by running `entrypoint` in the compiler, which will then call your code.**

The VM will first display the instruction contents of the bytecode file; you can use this to view any bytecode file, even if you don't run it.

To run the file, you can type `run` and press enter. The file will run as normal.

The VM also supports a debug mode, which can be activated by typing `debug` instead and pressing enter. The file will run, and each bytecode instruction will be printed as it runs, along with a snapshot of the stack above each. The top of the stack is on the left, the bottom is on the right.

### Sample Source Codes
Source codes for various example programs can be found in the `sample` folder in the root directory of the project.

### How To
#### Declare and Use Variables
```
var name: type; // declare a variable called name with the type type
name = expr; // assign the value of expr to the variale called name
print name; // evaluate the variable called name (and print it)
```
E.g.:
```
var num: byte;
num = 123b;
print num;
```
#### Define and Call Functions
```
function name(): return_type {
  // body statements go in here
}
```
```
unitName:functionName(param1, param2, ...); // call the function called functionName in the file called unitName
                                            // (unitName must contain the file extension)
// currently, it is not possible to call a function without explicitly
// writing the file it is in, even if it is in the same file.
```
E.g.
```
// in a file called main.txt
function main(): void {
  print main.mnrc:function2();
}

function function2(): byte {
  return 123b;
}
```
#### Use Pointers
A pointer type is written as a `&` followed by another type.
```
&type
```
Dynamic allocation can be done by writing `&!` followed by the size of the memory to allocate in the format `byte_amt pointer_amt`.
```
ptr = &! 1b 0b; // allocates a 1-byte, 0-pointer sized block of memory and 
                    // stores the pointer into a variable called ptr
// Note: it may be necessary to explicitly cast the right side of the equals sign to the variable type.
```
Dynamic allocation can be done _with an initializer_ by writing `&!` followed by an expression.
```
ptr = &! "hello"; // initializes the pointer with a string of characters
// Note: it may be necessary to explicitly cast the right side of the equals sign to the variable type.
```
Dynamic deallocation can be done by writing `*!` followed by an expression that evaluates to a pointer.
```
*! ptr; // frees the pointer at the variable called ptr
```
Referencing can be done by writing `&` followed by an expression.
```
var num: byte;
num = 123b;
ptr = &num; // sets the ptr to a pointer of the num (stored on the stack)
                // the variable num can be modified through ptr by dereferencing it
```
Dereferencing can be done by writing `*` followed by an expression.
```
var num2: byte;
num2 = *ptr; // dereferences ptr and sets it to num2
```

## Key Features

### Feature List

- Comments
- Functions
- Local variables
- Parameters
- Return statements
- If statements
- Operators
  - Equals
  - Add
  - Subtract
  - Multiply
  - Divide
  - Greater than
  - Lesser than
  - And
  - Or
  - Xor
  - Not
  - Left shift
  - Right shift
- While loops
  - Break
- Console Input
- Console Output
- Time
- Literals
  - String
  - Byte
  - Char
- Pointers
  - Reference
  - Dereference
  - Dynamic allocation
  - Dynamic deallocation

### Custom Syntax
A source code file specifies exactly what syntax structures it uses within it, kind of like importing classes in Java. Using the `compile with ...` and `compile without ...` syntaxes, which are the only syntaxes imported by default, a syntax can be added or removed by name.

In this system, programming structures found commonly within programming languages like `if` statements or `for` loops have no special status when compared to user-defined structures. In principle, they are more like an API, rather than strict language rules. They can be used or ignored by the compiler at will.

For instance, if you find yourself using the singleton design pattern a lot, you might find it helpful to define a `singleton` keyword which can be applied as a modifier to a class, just as `final` or `abstract` can. Or maybe you define an entirely new type of class entirely. Maybe you reject the existing OOP syntaxes and design your own functional paradigm language rules from scratch.

Syntaxes can take in per-usage parameters, which might include things like what other syntaxes can be used inside this one.

### Macros
Syntaxes don't need to be a new keyword or structure, they can produce the same effect as code that can already be written, just written differently. These are called macros, and are a subcategory of syntaxes that produce existing AST nodes. Macros exist in C, for example, in its pre-processor. 

For example, a macro that prints "Hello, World!" might be used like this:
```
compile with hello_world_macro
hw
```
where `hw` is the syntax defined by `hello_world_macro`, and this might produce AST equivalent to:
```
print("Hello, World!");
```

An example of a macro that "takes" parameters might look like:
```
compile with add_macro
print(add 3 5);
```
and might produce AST equivalent to:
```
print(8);
```

Macros used with syntaxes can create shorthands:
```
compile with compile_with_shorthand

cw hello_world_macro
cw add_macro

hw
print(add 3 5);
```
The word `cw` in this case might be defined by `compile_with_shorthand` as equivalent to `compile with`.

You can even make a macro that imports all the most commonly used syntaxes for you.